package com.rpg_game.game.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.hasEntry;
import static org.hamcrest.Matchers.hasItem;
import static org.hamcrest.Matchers.hasItems;
import static org.hamcrest.Matchers.is;
import org.junit.jupiter.api.AfterEach;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.http.HttpStatus;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.rpg_game.game.entity.Ability;
import com.rpg_game.game.entity.Character;
import com.rpg_game.game.entity.Effect;
import com.rpg_game.game.model.ActionResponse;
import com.rpg_game.game.model.BasicActionRequest;
import com.rpg_game.game.model.CharacterSnapshot;
import com.rpg_game.game.model.SkillActionRequest;
import com.rpg_game.game.repositories.CharacterRepository; 
import com.rpg_game.game.types.CharacterClass;
import com.rpg_game.game.types.Stat;

import io.restassured.RestAssured;
import static io.restassured.RestAssured.given;
import io.restassured.http.ContentType;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ActionRESTControllerTest {

    @LocalServerPort
    private int port;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired // Autowire the repository
    private CharacterRepository characterRepository;

    // To store IDs of characters created in a test for cleanup
    private List<Integer> createdCharacterIds = new ArrayList<>();

    @BeforeEach
    void setUp() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
        createdCharacterIds.clear(); // Clear IDs before each test
    }

    @AfterEach
    void tearDown() {
        // Delete all characters created during the test
        if (!createdCharacterIds.isEmpty()) {
            characterRepository.deleteAllById(createdCharacterIds);
            System.out.println("Cleaned up characters with IDs: " + createdCharacterIds);
        }
        createdCharacterIds.clear();
    }


    // --- Helper Methods ---
    // Creates and saves Character entity
    private Character createAndSaveCharacterEntity(String name, CharacterClass charClass, String team,
                                      int health, int attack, int defense, int speed, Ability ability) {
        Character character = new Character();
        // ID will be generated by DB
        character.setName(name);
        character.setCharacterClass(charClass);
        character.setTeam(team); 
        character.setBaseHealth(health);
        character.setBaseAttack(attack);
        character.setBaseDefense(defense);
        character.setBaseSpeed(speed);
        character.setAbility(ability); // Ability will be cascaded
        
        character.setCurrentHealth(health);
        character.setShield(0);
        character.setEffects(new ArrayList<>());
        
        Character savedCharacter = characterRepository.save(character);
        createdCharacterIds.add(savedCharacter.getId()); // Store ID for cleanup
        System.out.println("Saved character: " + savedCharacter.getName() + " with ID: " + savedCharacter.getId());
        assertNotNull(savedCharacter.getId(), "Saved character ID should not be null");
        if (savedCharacter.getAbility() != null) {
            assertNotNull(savedCharacter.getAbility().getId(), "Saved ability ID should not be null for " + savedCharacter.getName());
            if (savedCharacter.getAbility().getEffects() != null && !savedCharacter.getAbility().getEffects().isEmpty()) {
                savedCharacter.getAbility().getEffects().forEach(effect -> {
                    assertNotNull(effect.getId(), "Saved effect ID should not be null in ability " + savedCharacter.getAbility().getName());
                });
            }
        }
        return savedCharacter;
    }
    
    private CharacterSnapshot createSnapshot(Character character) {
        // Effects in snapshot might have IDs if they come from a persisted Ability, or null if newly applied runtime effects
        List<Effect> snapshotEffects = character.getEffects().stream()
            .map(e -> {
                Effect snapE = new Effect();
                snapE.setId(e.getId()); // Persisted effects will have IDs
                snapE.setName(e.getName());
                snapE.setBuff(e.isBuff());
                snapE.setTurns(e.getTurns()); // Runtime turns
                snapE.setHealthPercent(e.getHealthPercent());
                snapE.setAttackPercent(e.getAttackPercent());
                snapE.setDefensePercent(e.getDefensePercent());
                snapE.setSpeedPercent(e.getSpeedPercent());
                return snapE;
            }).collect(Collectors.toList());

        return new CharacterSnapshot(
            character.getId(),
            character.getTeam(),
            character.getCurrentHealth(),
            character.getShield(),
            snapshotEffects
        );
    }
    
    private Ability createAbility(String name, int scale, Stat stat, int heal, int shield, List<Effect> effects) {
        Ability ability = new Ability();
        // ID will be generated by DB when cascaded
        ability.setName(name);
        ability.setScale(scale);
        ability.setStat(stat);
        ability.setHeal(heal);
        ability.setShield(shield);
        if (effects != null) {
            // These effects are templates; new instances will be created when applied to characters
            // When Ability is saved, these effects will also be saved due to CascadeType.ALL
            ability.setEffects(effects.stream().map(e -> {
                Effect newE = new Effect(); // These will get their own IDs when persisted with Ability
                newE.setName(e.getName());
                newE.setBuff(e.isBuff());
                newE.setTurns(e.getTurns()); // This is the template turn count
                newE.setHealthPercent(e.getHealthPercent());
                newE.setAttackPercent(e.getAttackPercent());
                newE.setDefensePercent(e.getDefensePercent());
                newE.setSpeedPercent(e.getSpeedPercent());
                return newE;
            }).collect(Collectors.toList()));
        } else {
            ability.setEffects(new ArrayList<>());
        }
        return ability;
    }

    private Effect createEffect(String name, boolean isBuff, int turns, // This is a template effect
                                int healthPercent, int attackPercent, int defensePercent, int speedPercent) {
        Effect effect = new Effect();
        effect.setName(name);
        effect.setBuff(isBuff);
        effect.setTurns(turns);
        effect.setHealthPercent(healthPercent);
        effect.setAttackPercent(attackPercent);
        effect.setDefensePercent(defensePercent);
        effect.setSpeedPercent(speedPercent);
        return effect;
    }
    
    // Simplified mock character entity for basic tests, now also saves to DB
    private Character createAndSaveFullyBasicMockCharacterEntity(String name, String team, Integer health, Integer attack, Integer defense, Integer speed) {
        Character character = new Character();
        character.setName(name);
        character.setTeam(team);
        character.setBaseHealth(health); 
        character.setBaseAttack(attack);
        character.setBaseDefense(defense); 
        character.setBaseSpeed(speed);
        character.setAbility(createAbility("Mock Basic Ability", 0, Stat.ATK,0,0,null));
        character.setCurrentHealth(health);
        character.setShield(0);
        character.setEffects(new ArrayList<>());
        
        Character savedCharacter = characterRepository.save(character);
        createdCharacterIds.add(savedCharacter.getId());
        return savedCharacter;
    }

    private HashMap<Integer, CharacterSnapshot> buildLineupMapFromEntities(List<Character> characters) {
        HashMap<Integer, CharacterSnapshot> map = new HashMap<>();
        for (Character c : characters) {
            map.put(c.getId(), createSnapshot(c));
        }
        return map;
    }


    // --- Basic Tests (Adapted for DB interaction) ---
    @Test @DisplayName("POST /api/test/public/action/basic - Should return OK for a successful basic attack")
    void basicAttack_Success() throws Exception {
        Character attackerEntity = createAndSaveFullyBasicMockCharacterEntity("Hero", "PLAYER", 100, 50, 20, 10);
        Character targetEntity = createAndSaveFullyBasicMockCharacterEntity("Goblin", "ENEMY", 80, 30, 10, 8);
        
        HashMap<Integer, CharacterSnapshot> lineupMap = buildLineupMapFromEntities(Arrays.asList(attackerEntity, targetEntity));
        BasicActionRequest request = new BasicActionRequest(attackerEntity.getId(), targetEntity.getId(), lineupMap);

        int incomingDmg = attackerEntity.getBaseAttack(); 
        int targetDef = targetEntity.getBaseDefense();    
        double scaling = (double) incomingDmg / (incomingDmg + targetDef * 3.0);
        int expectedDamageDealt = (int) Math.round(incomingDmg * scaling);
        int expectedTargetHealthAfterAttack = Math.max(0, targetEntity.getCurrentHealth() - expectedDamageDealt);

        given().contentType(ContentType.JSON).body(objectMapper.writeValueAsString(request))
        .when().post("/api/test/public/action/basic")
        .then().log().all().statusCode(200)
        .body("validMove", is(true))
        .body("message", containsString("landed basic attack on"))
        .body("lineup.'" + targetEntity.getId() + "'.currHealth", equalTo(expectedTargetHealthAfterAttack));
    }

    @Test @DisplayName("POST /api/test/public/action/skill - Should return OK for a successful skill use and damage enemy")
    void skill_Success() throws Exception {
        Ability fireballAbility = createAbility("Fireball", 100, Stat.ATK, 0, 0, null); // Scale 100 = 100%
        Character casterEntity = createAndSaveCharacterEntity("Mage", CharacterClass.Ranger, "PLAYER", 100, 50, 20, 10, fireballAbility);
        Character enemyEntity = createAndSaveCharacterEntity("Imp", CharacterClass.Ranger, "ENEMY", 50, 10, 5, 5, createAbility("Scratch", 100, Stat.ATK, 0,0,null));

        HashMap<Integer, CharacterSnapshot> lineupMap = buildLineupMapFromEntities(Arrays.asList(casterEntity, enemyEntity));
        SkillActionRequest request = new SkillActionRequest(casterEntity.getId(), casterEntity.getTeam(), lineupMap);

        int abilityScalePercent = casterEntity.getAbility().getScale();
        int baseDmg = (abilityScalePercent * casterEntity.getBaseAttack()) / 100;
        int targetDef = enemyEntity.getBaseDefense(); 
        double damageScaling = (double) baseDmg / (baseDmg + targetDef * 3.0);
        int expectedDamageDealt = (int) Math.round(baseDmg * damageScaling); 
        int expectedEnemyHealth = Math.max(0, enemyEntity.getCurrentHealth() - expectedDamageDealt);

        given().contentType(ContentType.JSON).body(objectMapper.writeValueAsString(request))
        .when().post("/api/test/public/action/skill")
        .then().log().all().statusCode(200)
        .body("validMove", is(true))
        .body("message", containsString("Skill used by"))
        .body("lineup.'" + enemyEntity.getId() + "'.currHealth", equalTo(expectedEnemyHealth));
    }
    
    @Test @DisplayName("POST /api/test/public/action/basic - Should return NOT_FOUND if current character ID does not exist in DB")
    void basicAttack_InvalidCharacterId_NotInDB() throws Exception {
        Character targetEntity = createAndSaveFullyBasicMockCharacterEntity("Goblin", "ENEMY", 80, 30, 10, 8);
        HashMap<Integer, CharacterSnapshot> lineupMap = buildLineupMapFromEntities(List.of(targetEntity));
        // Use a non-existent ID for currentCharacterId
        BasicActionRequest request = new BasicActionRequest(9999, targetEntity.getId(), lineupMap); 

        given().contentType(ContentType.JSON).body(objectMapper.writeValueAsString(request))
        .when().post("/api/test/public/action/basic").then().log().all().statusCode(HttpStatus.NOT_FOUND.value());
    }

    @Test @DisplayName("POST /api/test/public/action/basic - Should return NOT_FOUND if target ID does not exist in DB")
    void basicAttack_InvalidTargetId_NotInDB() throws Exception {
        Character attackerEntity = createAndSaveFullyBasicMockCharacterEntity("Hero", "PLAYER", 100, 50, 20, 10);
        HashMap<Integer, CharacterSnapshot> lineupMap = buildLineupMapFromEntities(List.of(attackerEntity));
        BasicActionRequest request = new BasicActionRequest(attackerEntity.getId(), 9999, lineupMap);

        given().contentType(ContentType.JSON).body(objectMapper.writeValueAsString(request))
        .when().post("/api/test/public/action/basic").then().log().all().statusCode(HttpStatus.NOT_FOUND.value());
    }

    @Test @DisplayName("POST /api/test/public/action/basic - Should return BAD_REQUEST if target is already dead")
    void basicAttack_ServiceTargetAlreadyDead() throws Exception { 
        Character attackerEntity = createAndSaveFullyBasicMockCharacterEntity("Hero", "PLAYER", 100, 50, 20, 10);
        Character deadTargetEntity = createAndSaveFullyBasicMockCharacterEntity("DeadGoblin", "ENEMY", 0, 30, 10, 8);
        deadTargetEntity.setCurrentHealth(0); // Snapshot will reflect this
        // No need to save deadTargetEntity again if setCurrentHealth is just for snapshot.
        // The service fetches from DB where it was saved with health 0.

        HashMap<Integer, CharacterSnapshot> lineupMap = buildLineupMapFromEntities(Arrays.asList(attackerEntity, deadTargetEntity));
        BasicActionRequest request = new BasicActionRequest(attackerEntity.getId(), deadTargetEntity.getId(), lineupMap);
        
        given().contentType(ContentType.JSON).body(objectMapper.writeValueAsString(request))
        .when().post("/api/test/public/action/basic").then().log().all().statusCode(HttpStatus.BAD_REQUEST.value())
        .body("message", equalTo("Target is already dead"));
    }

    @Test @DisplayName("POST /api/test/public/action/skill - Should return NOT_FOUND if current character ID is invalid")
    void skill_InvalidCharacterId() throws Exception { 
        HashMap<Integer, CharacterSnapshot> lineupMap = new HashMap<>();
        SkillActionRequest request = new SkillActionRequest(9999, "PLAYER", lineupMap);
        given().contentType(ContentType.JSON).body(objectMapper.writeValueAsString(request))
        .when().post("/api/test/public/action/skill").then().log().all().statusCode(HttpStatus.NOT_FOUND.value());
    }

    // --- Combat Scenario Test (Adapted for DB interaction) ---
    @Test
    @DisplayName("Combat Scenario: 3v3 Multiple Turns with DB Persistence")
    // @Transactional // Optional: Use if you want Spring to manage transaction boundaries for the test method
                    // This can help with lazy loading issues if entities are detached, but might also roll back changes.
                    // For this kind of test, explicit save/delete might be clearer.
    void combatScenario_3v3_MultipleTurns() throws Exception {
        Effect shieldAuraEffect = createEffect("Shield Aura", true, 2, 0, 0, 20, 0);
        Ability crusaderShieldWall = createAbility("Shield Wall", 0, Stat.DEF, 0, 150, List.of(shieldAuraEffect));
        Effect selfAttackBoostEffect = createEffect("Self Attack Boost", true, 1, 0, 30, 0, 0);
        Ability rangerPowerShot = createAbility("Power Shot", 200, Stat.ATK, 0, 0, List.of(selfAttackBoostEffect));
        Ability priestGroupHeal = createAbility("Group Heal", 0, Stat.ATK, 100, 0, null);
        Effect weakenAttackDebuff = createEffect("Weaken Attack", false, 2, 0, -25, 0, 0);
        Effect weakenDefenseDebuff = createEffect("Weaken Defense", false, 2, 0, 0, -25, 0);
        Ability leechCurse = createAbility("Weakening Curse", 50, Stat.ATK, 0, 0, Arrays.asList(weakenAttackDebuff, weakenDefenseDebuff));
        Effect teamAttackBuffEffect = createEffect("Team Attack Boost", true, 2, 0, 20, 0, 0);
        Effect teamSpeedBuffEffect = createEffect("Team Speed Boost", true, 2, 0, 0, 0, 15);
        Ability saintBlessing = createAbility("Divine Blessing", 0, Stat.MAX_HP, 50, 0, Arrays.asList(teamAttackBuffEffect, teamSpeedBuffEffect));
        Ability enemyRangerFocusedStrike = createAbility("Focused Strike", 150, Stat.ATK, 0, 0, null);

        // Create and Save Character Entities
        Character pCrusader = createAndSaveCharacterEntity("Valerius", CharacterClass.Crusader, "PLAYER", 200, 60, 80, 50, crusaderShieldWall);
        Character pRanger = createAndSaveCharacterEntity("Lyra", CharacterClass.Ranger, "PLAYER", 120, 80, 40, 70, rangerPowerShot);
        Character pPriest = createAndSaveCharacterEntity("Seraphina", CharacterClass.Priest, "PLAYER", 100, 50, 30, 60, priestGroupHeal);
        Character eLeech = createAndSaveCharacterEntity("Nox", CharacterClass.Leech, "ENEMY", 110, 65, 35, 65, leechCurse);
        Character eSaint = createAndSaveCharacterEntity("Aurelius", CharacterClass.Saint, "ENEMY", 130, 40, 50, 55, saintBlessing);
        Character eRanger = createAndSaveCharacterEntity("Grimfang", CharacterClass.Ranger, "ENEMY", 125, 75, 40, 75, enemyRangerFocusedStrike);

        // The holder for the current state of the lineup (map of snapshots)
        final HashMap<Integer, CharacterSnapshot>[] currentLineupMapHolder = new HashMap[]{
            buildLineupMapFromEntities(Arrays.asList(pCrusader, pRanger, pPriest, eLeech, eSaint, eRanger))
        };
        
        ActionResponse response;
        String requestBody;

        System.out.println("Initial Lineup Snapshots: " + currentLineupMapHolder[0]);

        // === TURN 1: Player Ranger (Lyra, ID from pRanger.getId()) ===
        SkillActionRequest skillReq1 = new SkillActionRequest(pRanger.getId(), pRanger.getTeam(), currentLineupMapHolder[0]);
        requestBody = objectMapper.writeValueAsString(skillReq1);
        
        int lyraAtk = pRanger.getBaseAttack();
        int powerShotScale = pRanger.getAbility().getScale();
        int grimfangDef = eRanger.getBaseDefense();
        int t1BaseDmg = (powerShotScale * lyraAtk) / 100;
        double t1Scaling = (double) t1BaseDmg / (t1BaseDmg + grimfangDef * 3.0);
        int t1ExpectedDamage = (int) Math.round(t1BaseDmg * t1Scaling);
        int eRangerExpectedHealthT1 = Math.max(0, currentLineupMapHolder[0].get(eRanger.getId()).currHealth() - t1ExpectedDamage);

        response = given().contentType(ContentType.JSON).body(requestBody)
                .when().post("/api/test/public/action/skill").then().log().all().statusCode(200)
                .body("lineup." + eRanger.getId() + ".currHealth", equalTo(eRangerExpectedHealthT1))
                .body("lineup." + pRanger.getId() + ".effects", hasItem(allOf(hasEntry("name", "Self Attack Boost"))))
                .extract().as(ActionResponse.class);
        assertTrue(response.validMove());
        currentLineupMapHolder[0] = response.lineup(); 

        assertEquals(eRangerExpectedHealthT1, currentLineupMapHolder[0].get(eRanger.getId()).currHealth());
        System.out.println("T1 Done. Grimfang Health: " + currentLineupMapHolder[0].get(eRanger.getId()).currHealth());


        // === TURN 2: Enemy Leech (Nox, ID from eLeech.getId()) ===
        SkillActionRequest skillReq2 = new SkillActionRequest(eLeech.getId(), eLeech.getTeam(), currentLineupMapHolder[0]);
        requestBody = objectMapper.writeValueAsString(skillReq2);

        int noxAtk = eLeech.getBaseAttack();
        int leechCurseScale = eLeech.getAbility().getScale();
        int lyraDefT2 = currentLineupMapHolder[0].get(pRanger.getId()) != null ? pRanger.getBaseDefense() : 40; // Fallback if snapshot missing
        
        int t2BaseDmg = (leechCurseScale * noxAtk) / 100; 
        double t2Scaling = (double) t2BaseDmg / (t2BaseDmg + lyraDefT2 * 3.0);
        int t2ExpectedDamage = (int) Math.round(t2BaseDmg * t2Scaling);
        int pRangerCurrentHealthT2 = currentLineupMapHolder[0].get(pRanger.getId()) != null ? currentLineupMapHolder[0].get(pRanger.getId()).currHealth() : pRanger.getCurrentHealth();
        int pRangerExpectedHealthT2 = Math.max(0, pRangerCurrentHealthT2 - t2ExpectedDamage);


        response = given().contentType(ContentType.JSON).body(requestBody)
                .when().post("/api/test/public/action/skill").then().log().all().statusCode(200)
                .body("lineup." + pRanger.getId() + ".currHealth", equalTo(pRangerExpectedHealthT2))
                .body("lineup." + pRanger.getId() + ".effects", hasItems(
                    allOf(hasEntry("name", "Weaken Attack")), 
                    allOf(hasEntry("name", "Weaken Defense"))))
                .extract().as(ActionResponse.class);
        assertTrue(response.validMove());
        currentLineupMapHolder[0] = response.lineup();

        assertEquals(pRangerExpectedHealthT2, currentLineupMapHolder[0].get(pRanger.getId()).currHealth());
        System.out.println("T2 Done. Lyra Health: " + currentLineupMapHolder[0].get(pRanger.getId()).currHealth());

        // === TURN 3: Player Crusader (Valerius, ID from pCrusader.getId()) ===
        SkillActionRequest skillReq3 = new SkillActionRequest(pCrusader.getId(), pCrusader.getTeam(), currentLineupMapHolder[0]);
        requestBody = objectMapper.writeValueAsString(skillReq3);

        response = given().contentType(ContentType.JSON).body(requestBody)
                .when().post("/api/test/public/action/skill").then().log().all().statusCode(200)
                .body("lineup." + pCrusader.getId() + ".shield", equalTo(crusaderShieldWall.getShield()))
                .body("lineup." + pRanger.getId() + ".shield", equalTo(crusaderShieldWall.getShield()))
                .body("lineup." + pCrusader.getId() + ".effects", hasItem(allOf(hasEntry("name", "Shield Aura"))))
                .extract().as(ActionResponse.class);
        assertTrue(response.validMove());
        currentLineupMapHolder[0] = response.lineup();
        
        assertEquals(crusaderShieldWall.getShield(), currentLineupMapHolder[0].get(pCrusader.getId()).shield());
        System.out.println("T3 Done. Valerius Shield: " + currentLineupMapHolder[0].get(pCrusader.getId()).shield());

        // === TURN 4: Enemy Saint (Aurelius, ID from eSaint.getId()) ===
        SkillActionRequest skillReq4 = new SkillActionRequest(eSaint.getId(), eSaint.getTeam(), currentLineupMapHolder[0]);
        requestBody = objectMapper.writeValueAsString(skillReq4);
        
        CharacterSnapshot eLeechSnapBeforeHeal = currentLineupMapHolder[0].get(eLeech.getId());
        int eLeechHealthBeforeHeal = eLeechSnapBeforeHeal.currHealth();
        int saintHealAmount = saintBlessing.getHeal();

        response = given().contentType(ContentType.JSON).body(requestBody)
                .when().post("/api/test/public/action/skill").then().log().all().statusCode(200)
                .extract().as(ActionResponse.class);
        assertTrue(response.validMove());
        currentLineupMapHolder[0] = response.lineup();

        CharacterSnapshot eLeechSnapAfterHeal = currentLineupMapHolder[0].get(eLeech.getId());
        int eLeechExpectedHealthT4 = Math.min(eLeech.getBaseHealth(), eLeechHealthBeforeHeal + saintHealAmount);
        assertEquals(eLeechExpectedHealthT4, eLeechSnapAfterHeal.currHealth());
        assertTrue(eLeechSnapAfterHeal.effects().stream().anyMatch(e -> e.getName().equals("Team Attack Boost")));
        System.out.println("T4 Done. " + eLeech.getName() + " health: " + eLeechSnapAfterHeal.currHealth());

        // === TURN 5: Player Priest (Seraphina, ID from pPriest.getId()) ===
        SkillActionRequest skillReq5 = new SkillActionRequest(pPriest.getId(), pPriest.getTeam(), currentLineupMapHolder[0]);
        requestBody = objectMapper.writeValueAsString(skillReq5);

        CharacterSnapshot pRangerSnapBeforeHeal = currentLineupMapHolder[0].get(pRanger.getId());
        int pRangerHealthBeforeHeal = pRangerSnapBeforeHeal.currHealth();
        int priestHealAmount = priestGroupHeal.getHeal();

        response = given().contentType(ContentType.JSON).body(requestBody)
                .when().post("/api/test/public/action/skill").then().log().all().statusCode(200)
                .extract().as(ActionResponse.class);
        assertTrue(response.validMove());
        currentLineupMapHolder[0] = response.lineup();

        CharacterSnapshot pRangerSnapAfterHeal = currentLineupMapHolder[0].get(pRanger.getId());
        int pRangerExpectedHealthT5 = Math.min(pRanger.getBaseHealth(), pRangerHealthBeforeHeal + priestHealAmount);
        assertEquals(pRangerExpectedHealthT5, pRangerSnapAfterHeal.currHealth());
        System.out.println("T5 Done. " + pRanger.getName() + " health: " + pRangerSnapAfterHeal.currHealth());
    }
}